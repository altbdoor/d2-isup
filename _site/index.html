<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./destiny-tricorn.svg" />

    <title>d2-isup &middot; Is Destiny 2 service up?</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/mvp.css@1.16.0/mvp.min.css"
    />
  </head>
  <body x-data="root">
    <header>
      <h1 x-text="today.toLocaleString(undefined, fullDateTimeFormat)">...</h1>
      <h2 :hidden="!isMaintenance" hidden>
        <mark>
          <span :hidden="!isMaintenance" hidden>Maintenance has started.</span>
          <span :hidden="!isServerDown" hidden>Server is offline.</span>
        </mark>

        <u :hidden="isServerDown" hidden>Server is still online.</u>
      </h2>

      <h2 :hidden="isMaintenance" hidden>No maintenance at the moment.</h2>
    </header>

    <main>
      <section>
        <canvas id="chart" height="200"></canvas>
      </section>

      <section>
        <div style="padding: 1rem 0">
          <a href="?mode=24h">
            <b x-show="timeDisplayMode === '24h'">24 hour mode</b>
            <i x-show="timeDisplayMode === '12h'">24 hour mode</i>
          </a>
          <a href="?mode=12h">
            <b x-show="timeDisplayMode === '12h'">12 hour mode</b>
            <i x-show="timeDisplayMode === '24h'">12 hour mode</i>
          </a>
        </div>
      </section>

      <section>
        <template x-for="entry in activeEntries">
          <aside class="entry">
            <b
              x-text="entry.maintenance_time_start.toLocaleString(undefined, fullDateTimeFormat)"
            ></b>
            <ul>
              <li>
                <u>Maintenance start:</u>
                <br />
                <span
                  x-text="entry.maintenance_time_start.toLocaleString(undefined, fullDateTimeFormat)"
                ></span>
              </li>
              <li x-show="entry.server_down_start.getTime() > 1000">
                <u>Server turned off:</u>
                <br />
                <span
                  x-text="entry.server_down_start.toLocaleString(undefined, fullDateTimeFormat)"
                ></span>
              </li>
              <li x-show="entry.server_down_end.getTime() > 1000">
                <u>Server turned on:</u>
                <br />
                <span
                  x-text="entry.server_down_end.toLocaleString(undefined, fullDateTimeFormat)"
                ></span>
              </li>
              <li>
                <u>Maintenance end:</u>
                <br />
                <span
                  x-text="entry.maintenance_time_end.toLocaleString(undefined, fullDateTimeFormat)"
                ></span>
              </li>
            </ul>

            <p x-text="entry.description"></p>
          </aside>
        </template>
      </section>

      <section>
        <div style="padding-top: 1rem; text-align: center">
          To be sure, please check the
          <a
            href="https://help.bungie.net/hc/en-us/articles/360049199271-Destiny-Server-and-Update-Status"
            target="_blank"
            referrerpolicy="no-referrer"
            >Server and update status page</a
          >, the
          <a
            href="https://x.com/BungieHelp"
            target="_blank"
            referrerpolicy="no-referrer"
            >official BungieHelp</a
          >, or the
          <a href="https://mastodon.social/@bungiehelp">
            unofficial BungieHelp </a
          >.
        </div>
      </section>
    </main>

    <script>
      /**
        @typedef {Object} MaintenanceEvent
        @property {Date} maintenance_time_start
        @property {Date} maintenance_time_end
        @property {Date} server_down_start
        @property {Date} server_down_end
        @property {string} description
      */

      document.addEventListener("alpine:init", () => {
        function root() {
          const today = new Date("2024-10-28T10:00:00-07:00");
          const oneDayInMs = 1 * 24 * 60 * 60 * 1000;

          const todayRef = new Date(today);
          todayRef.setMinutes(0, 0, 0);
          const daysBefore = new Date(todayRef.getTime() - oneDayInMs / 4);
          const daysAfter = new Date(todayRef.getTime() + 2 * oneDayInMs);

          const url = new URL(window.location.href);
          const timeDisplayMode = url.searchParams.get("mode") || "12h";

          /** @type {Intl.DateTimeFormatOptions} */
          const timeFormatOpt = {
            hour: "numeric",
            minute: "numeric",
            hour12: timeDisplayMode === "12h",
          };

          /** @type {Intl.DateTimeFormatOptions} */
          const dateShortFormatOpt = {
            day: "numeric",
            month: "short",
            year: "numeric",
          };

          return {
            today,
            isMaintenance: false,
            isServerDown: false,
            timeDisplayMode,

            /** @type {Intl.DateTimeFormatOptions} */
            fullDateTimeFormat: {
              ...dateShortFormatOpt,
              ...timeFormatOpt,
            },

            /** @type {MaintenanceEvent[]} */
            activeEntries: [],

            async init() {
              /** @type {any[]} */
              const res = await fetch("./data.json").then((x) => x.json());

              const allEntries = res
                .map((entry) => {
                  /** @type {MaintenanceEvent} */
                  const entryData = Object.keys(entry).reduce((acc, key) => {
                    if (key.endsWith("_start") || key.endsWith("_end")) {
                      acc[key] = new Date(entry[key]);
                    } else {
                      acc[key] = entry[key];
                    }

                    return acc;
                  }, {});

                  return entryData;
                })
                .filter((entry) => {
                  return (
                    entry.maintenance_time_start >= daysBefore &&
                    entry.maintenance_time_end <= daysAfter
                  );
                });

              const activeEntries = allEntries.filter(
                (entry) =>
                  entry.maintenance_time_start <= today &&
                  entry.maintenance_time_end >= today,
              );

              if (activeEntries.length > 0) {
                this.isMaintenance = true;

                this.isServerDown = activeEntries.some(
                  (entry) =>
                    entry.server_down_start <= today &&
                    entry.server_down_end >= today,
                );
              }

              this.activeEntries = activeEntries;

              const datasets = [
                {
                  label: "Maintenance window",
                  order: 30,
                  borderWidth: 2,
                  borderColor: "rgb(255, 205, 86)",
                  backgroundColor: "rgba(255, 205, 86, 0.6)",
                  data: allEntries.map((entry) => ({
                    y: 0,
                    x: [
                      entry.maintenance_time_start.getTime(),
                      entry.maintenance_time_end.getTime(),
                    ],
                  })),
                },
                {
                  label: "Server down",
                  order: 20,
                  borderWidth: 2,
                  borderColor: "rgb(255, 99, 132)",
                  backgroundColor: "rgba(255, 99, 132, 0.6)",
                  data: allEntries.map((entry) => ({
                    y: 0,
                    x: [
                      entry.server_down_start.getTime(),
                      entry.server_down_end.getTime(),
                    ],
                  })),
                },
                {
                  label: "Now",
                  order: 10,
                  inflateAmount: 2,
                  backgroundColor: "rgb(54, 162, 235)",
                  data: [
                    {
                      y: 0,
                      x: [today.getTime(), today.getTime()],
                    },
                  ],
                },
              ];

              const tooltipPlugin = {
                xAlign: "right",
                yAlign: "bottom",
                caretSize: 0,
                bodyFont: { size: 14 },
                callbacks: {
                  title: () => "",
                  label: (item) => {
                    const xVals = item.raw.x;
                    if (xVals.length !== 2) {
                      return "";
                    }

                    const startDate = new Date(xVals[0]);
                    const endDate = new Date(xVals[1]);

                    return [
                      startDate.toLocaleString(undefined, timeFormatOpt),
                      "-",
                      endDate.toLocaleString(undefined, timeFormatOpt),
                    ].join(" ");
                  },
                },
              };

              const chart = new Chart(document.getElementById("chart"), {
                type: "bar",
                data: { datasets },
                options: {
                  animation: false,
                  indexAxis: "y",
                  maintainAspectRatio: false,
                  resizeDelay: 100,
                  scales: {
                    x: {
                      type: "time",
                      position: "top",
                      min: daysBefore.getTime(),
                      max: daysAfter.getTime(),
                      ticks: {
                        autoSkip: true,
                        minRotation: 90,
                        major: { enabled: true },
                        callback: (value) => {
                          const tmpDate = new Date(value);
                          if (tmpDate.getHours() === 0) {
                            return tmpDate.toLocaleString(
                              undefined,
                              dateShortFormatOpt,
                            );
                          }

                          return tmpDate.toLocaleString(
                            undefined,
                            timeFormatOpt,
                          );
                        },
                        font: (ctx) => {
                          const tmpDate = new Date(ctx.tick.value);
                          if (tmpDate.getHours() === 0) {
                            return { weight: "bold", size: 14 };
                          }

                          return {};
                        },
                      },
                      time: { unit: "hour" },
                    },
                    y: { stacked: true },
                  },
                  elements: {
                    bar: {
                      borderSkipped: false,
                    },
                  },
                  plugins: {
                    legend: { position: "bottom" },
                    tooltip: tooltipPlugin,
                  },
                },
              });
            },
          };
        }

        Alpine.data("root", root);
      });
    </script>

    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.3/dist/cdn.min.js"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.5/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
  </body>
</html>
